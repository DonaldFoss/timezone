# Swipe

Applications are going to use dates the way people use dates in the real world.
They are not a collection of attributes, but a point on a timeline, interesting
only relative to other points on that timeline.

Objects were all the rage, it is a wonder that we didn't have a regular
expression factory pattern, and build regular expressions using getters and
setters, instead of parsing regular expression patterns. That is what the date
object is like.

# Objectives

Development tasks:

 * Parse Olson file.
 * Create searchable structure for offsets and rules.
 * Create Olson file compiler utility.
 * Create tests with controls generated by a mature timezone library such as
   CPAN's DateTime::TimeZone or UNIX `date`.
 * Create a timezone conversion method.
 * Create a date offset method.
 * Create French and German locales to seed the locale set.

Decisions:

 * Olson files are compiled into JSON, loaded as JSON.
 * On the browser side, it is the job of the client to initialize the timezone
   data, to load it and whatnot.
 * In Node.js, timezone data is loaded *synchonously* as needed, or at startup.
 * Make a magic function that does format, parse and date math based on
   parameter order, to simplify import and minimize burden on namespace.

## Just In Time Time

Always adjust your dates just in time. Store your dates in UTC. Convert them
when they are displayed. Record events using UTC on the server, not the client.
You cannot trust the client time, you do not know if the clock is set correctly,
you can't keep the user from adjusting it, even you try to account for skew.

UTC timestamps will always indicate a particular second since the epoch.


If you are doing math in hours, minutes, seconds or milliseconds, this will
reflect the UTC time.

If you are day math, you may land on a daylight savings time shift. If this is
the case, then the last day is treated as 24 hours. Otherwise, if are on a day
at 6:00 PM standard time, and go back six months to the same day, different
month, in daylight savings time, the time will still be 6:00 PM. (Use real
Detroit, Michigan examples.)

@ tz

The namespace.

~ tz(date, offset..., zone, locale)

One function to rule them all and in the darkness bind them.

### Lost Parable

You might be located in St. Louis, but your customers are in Osaka. They have
servers on site in Osaka, communicating with servers in St. Louis. When you run
a report to find the cause of a spike, you're going to have to pick a timezone
for that That's okay.  Your reports can toggle between Central Time and Japan
Standard Time.

If you're using a database, and you want to use TIMESTAMP, then make sure that
your database won't trip you up by adding the timezone offset of the server.

MySQL is not timezone aware, so I set the timezone of my MySQL servers to UTC,
because MySQL always adds the host machines current timezone offset, which is
arbitrary information that is external to your application and not recorded
anywhere within the database. That is, if you export your MySQL database, it
doesn't record what timezone it was running in when the database was created.

### Lost Parable

Imagine a computer programmer from New York working for a week on site in San
Francisco. She remembers that she was supposed to send out the invites for her
daughter's birthday party next month.

She takes a break from her wor, and uses your cool web invite application to
send invites to a hundred people, but you used JavaScript `Date` to parse the
value from the date picker, and the time was formatted offset to the time of
workstation she was assigned for the job, and a month from now, everyone will be
showing up three hours late to a birthday party for a broken-hearted little
girl.

Thus, if we want to allow the user to move appointments forward by a number of
hours on their calendar, which would be presented in their local time, Timezone
will add the hours and then adjust the time if we enter or leave daylight
savings time.

Timezone can perform date math in both POSIX time and local time. When adding or
subtracting by hours, minutes, seconds, and milliseconds, Timezone will adjust
for daylight savings time.

As an example, let's say the you're writing a calendar application for a travel
web site, so that frequent travelers can choose from fights that do not conflict
with their scheduled appointments. To use the feature, the customers sync their
calendar with the reservation system using any iCalendar compatible calendar.
Now when they search for flights, a flight that interferes with an appointment
is flagged, so the user can see what appointments need to be rescheduled to take
that flight.

If you are a New Yorker who wants to check to see if you're going to miss any
conference calls if you take a particular flight from Vilinus to San Francisco,
you need check to see if the dates in your Eastern Time calendar fit between an
Eastern Eurpoean Time departure and a Pacific Time arrival.

Obviously, this query needs to adjust these different times to a common
timezone, which is UTC for POSIX time. The application needs to display the
appointment dates, and the arrival and departure date in their with respective
time zones offsets.

These days should all be converted to a common timezone to check for conflicts,
then the various times should be presented according to the local time of the
event.

It works with the strategy of using POSIX time as the persistent representation
of a timestamp, and converting that universal time to wall clock time for
presentation.

POSIX time is the notion of the passage of time common to all POSIX compliant
UNIX systems. It is milliseconds since the epoch in UTC. This represents a
specific point in time.

The milliseconds since the epoch in UTC value is an absolute value that is not
affected by the politics of timezones and daylight savings time. It is
considered a stable representation of a point in time, that is suitable for
storage in a database.

Strings are used to represent wall clock time. If a time needs to be presented
to a user,

You can use the `tz` function to create a date format for display, one that
cannot be in turn parsed by the `tz` function. That's fine.

## Usage

Timezone exports a single function to keep from polluting the namespace of the
client application. This single method accepts parameters similar to UNIX date.

The first parameter is always a date, either as milliseconds since the epoch as
UTC or a date string to parse.

Other arguments can appear in any order.

 * *timezone* &mdash; A timezone offset to use when parsing or formatting such
   as `EDT` or `America/Detroit`.
 * *locale* &mdash; A locale to use when parsing or formatting such as `en_US`
   or `zh_CN`.
 * *format* &mdash; A UNIX date format specifier such as `%Y/%d/%m` to return
   the date as a formatted date string, or else a switch to indicate a  canned
   format specifier like `--rfc822` or `--rfc-3339=ns`.
 * *offsets* &mdash; A set of offsets to apply to the date like `+1 day -43 minutes`.

You can pass these in any order after the initial date parameter, the `tz`
function knows what you mean.

Only one *timezone*, *locale* or *format* can be applied to a date, so if a
value is repeated for one of these parameter types, the first value is used,
subsequent values are ignored.

The *offsets* parameter can be specified multiple times. The offsets are applied
to the date in the order in which they are passed to the `tz` function.

The return value is always either milliseconds since the epoch as UTC or a date
string if the `tz` function was passed a format specifier.

## Date Math

If we land on a time missing due to the start daylight savings time, we
continue in the direction we were going, adding an additional day if we are
doing addition, subtracting an additional day if we are doing subtraction. We
then go back by 24 hours. This gives us the same counter intuitive times as
Java's Calendar.

## Where Did `Date` Go?

Why use Timezone instead of the JavaScript `Date` object? Because the JavaScript
`Date` object is not timezone aware. Because unlike the JavaScript `Date`
object, time is not object oriented.

Why not monkey patch the `Date` object to try to get it to do the right thing?
Because it is already quite the wrong thing. It exposes a point in time as a
bill of materials, with getters and setters for minutes, years, hours, etc. Time
is a point on line, not an assemlage of integer properties.

applies the timezone offset of the local
machine. That is an entirely ***arbitrary*** timezone setting for a web or
mobile application that can run anywhere for multiple users.

## Overview

Instead of monkey patching the JavaScript `Date` object, to create a method
chained monster, we have a single function, with a short name, `tz` that
operates on POSIX timestamps and date strings.

One function can parse, format and calculate dates. Give it a handful of human
readable parameters, it will figure out what to do.

With Timezone Why use Timezone instead of `Date`? Because `Date` is not timezone
aware. It has timezone offset support so feeble as to be useless. It doesn't
parse, format or perform date math, but if you have a go at it, 
